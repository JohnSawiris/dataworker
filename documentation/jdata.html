<!DOCTYPE html>
<html lang="en">
    <head>
        <link href="bootstrap/css/bootstrap.css" rel="stylesheet" media="screen">
        <link href="jdata.css" rel="stylesheet">

        <script src="http://code.jquery.com/jquery.js"></script>
        <script src="bootstrap/js/bootstrap.js"></script>

        <title>JData</title>
    </head>
    <body>
        <div class="container" id="top">
            <div class="header_row row">
                <div class="span12">
                    <h1>JData</h1>
                </div>
            </div>
            <div class="row">
                <div class="span3">
                    <ul class="nav nav-tabs nav-stacked affix">
                        <li><a href="#top">JData</a></li>
                        <li class="nav-header">Get started!</li>
                        <li><a href="#construct">Construct</a></li>
                        <li><a href="#stream">Streaming Data</a></li>
                        <li><a href="#clone">Clone</a></li>
                        <li class="nav-header">Manipulate the dataset!</li>
                        <li><a href="#alter_columns">Alter columns</a></li>
                        <li><a href="#append">Append</a></li>
                        <li><a href="#filter">Filter</a></li>
                        <li><a href="#group">Group</a></li>
                        <li><a href="#join">Join</a></li>
                        <li><a href="#limit">Limit</a></li>
                        <li><a href="#remove_columns">Remove columns</a></li>
                        <li><a href="#hide_columns">Hide columns</a></li>
                        <li><a href="#sort">Sort</a></li>
                        <li class="nav-header">Access the dataset!</li>
                        <li><a href="#get_dataset">Get dataset</a></li>
                        <li><a href="#get_columns">Get columns</a></li>
                        <li><a href="#get_columns_and_records">Get columns and records</a></li>
                        <li><a href="#get_number_of_records">Get number of records</a></li>
                        <li><a href="#get_distinct">Get distinct</a></li>
                        <li><a href="#paginate">Paginate</a></li>
                        <li><a href="#partition">Partition</a></li>
                        <li><a href="#render">Render</a></li>
                    </ul>
                </div>
                <div class="span9">
                    <section id="construct">
                        <h3>Construct</h3>
                        <p>JData takes an array of records to construct the initial dataset. The first record defines column properties.</p>
                        <pre>
    var dataset = [
        [
            {
                name: 'column_a',
                title: 'Column A',
                agg_type: 'max',
                sort_type: 'alpha'
            },
            {
                name: 'column_b',
                title: 'Column B',
                agg_type: 'max',
                sort_type: 'alpha'
            },
            {
                name: 'column_c',
                title: 'Column C',
                agg_type: 'min',
                sort_type: 'alpha'
            }
        ],

        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
        [ 'gummy',       'power',     'star' ]
    ];

    var d = new JData(dataset);</pre>
                        <p>It is also possible to just supply column names:</P>
                        <pre>
    var dataset = [
        [ 'column_a', 'column_b', 'column_c' ],

        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
        [ 'gummy',       'power',     'star' ]
    ];

    var d = new JData(dataset);</pre>
                        <p>If only column names are supplied, the following default column properties are used:</p>
                        <ul>
                            <li><code>title</code>: <code>column_name</code></li>
                            <li><code>agg_type</code>: 'max'</li>
                            <li><code>sort_type</code>: 'alpha'</li>
                        </ul>
                        <p>Additionally, you should give JData an error handler (otherwise JData will just fail silently) using the <code>on_error</code> method:</p>
                        <pre>
    var d = new JData(dataset).on_error(function (error_msg) {
        alert(error_msg);
    });</pre>
                    <h5>Error handling</h5>
                    <p>JData can be provided with an error handler:</p>
                    <pre>
    d.on_error(function (msg) {
        alert(msg);
    });</pre>
                    <p>By default, errors are printed to the console.</p>
                    </section>
                    <section id="stream">
                        <h3>Streaming Data</h3>
                        <h5>Via Websockets</h5>
                        <p>Alternatively, JData can stream data from a WebSocket server:</p>
                        <pre>
    var d = new JData({
        datasource   : "ws://127.0.0.1:8888",
        authenticate : "{}",
        request      : '{"cmd":"request_dataset"}'
    });</pre>
                        <p><code>datasource</code> should be the URL of the websocket server.</p>
                        <p><code>authenticate</code> is optional. If present, will be the first message sent to the server upon connecting.</p>
                        <p><code>request</code> is sent after <code>authenticate</code>.<p>
                        <p>After the request is sent, JData will expect a reply in the form of a JSON object with <code>total_num_rows</code> and <code>columns</code> properties such as:</p>
                        <pre>
    {
        total_num_rows => 10,
        columns        => [ 'column_a', 'column_b', 'column_c' ]
    }</pre>
                        <p><code>total_num_rows</code> should be the number of rows to expect in that dataset.</p>
                        <p><code>columns</code> should be the columns of the expected dataset. They can be provided as simple column names or as hashes with custom column properties.</p>
                        <p>Note JData cannot proceed without first knowing the columns and the total number of expected rows. That being said, these two properties may be transmitted separately. For example:</p>
                        <pre>
    // First message:
    { total_num_rows => 10 }

    // Second message:
    { columns => [ 'column_a', 'column_b', 'column_c' ] }</pre>
                        <p>Afterwards, JData will expect arrays of dataset rows from the server. These rows will be appended to the dataset. The reply will be similar to the following:</p>
                        <pre>
    [
        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
        [ 'gummy',       'power',     'star' ]
    ]</pre>
                        <p>The <code>on_receive_rows</code> callback will be called whenever rows are received from the Websocket server. This callback can be set with the <code>on_receive_rows</code> method:</p>
                        <pre>
    d.on_receive_rows(function (num_rows) {
        alert("Received " + num_rows + " rows.");
    });</pre>
                        <p>Alternatively, this callback can be passed into the constructor:</p>
                        <pre>
    var d = new JData({
        datasource      : "ws://127.0.0.1:8888",
        authenticate    : "{}",
        request         : '{"cmd":"request_dataset"}',
        on_receive_rows : function (num_rows) {
            alert(num_rows + " rows received.");
        }
    });</pre>
                        <p>If not set, this callback defaults to doing nothing.</p>
                        <p>The <code>on_all_rows_received</code> callback is called when all expected rows have been received from the Websocket server. This callback can be set with the <code>on_all_rows_received</code> method:</p>
                        <pre>
    d.on_all_rows_received(function () {
        alert("All rows have been received!");
    });</pre>
                        <p>Alternatively, this callback can be passed into the constructor:</p>
                        <pre>
    var d = new JData({
        datasource           : "ws://127.0.0.1:8888",
        authenticate         : "{}",
        request              : '{"cmd":"request_dataset"}',
        on_receive_rows      : function (num_rows) {
            alert(num_rows + " rows received.");
        }
        on_all_rows_received : function () {
            alert("All rows have been received!");
        }
    });</pre>
                        <p>If not set, this callback does nothing.</p>
                        <h5>Via AJAX</h5>
                        <p>If WebSockets are not available, data can be received via AJAX as well:</p>
                        <pre>
    var d = new JData({
        datasource           : "http://127.0.0.1:8888",
        request              : '?this=is;a=query;string',
        on_all_rows_received : function () {
            alert("all rows have been received!");
        }
    });</pre>
                        <p><code>datasource</code> should be the base url to send GET requests to.</p>
                        <p><code>request</code> should be the query string to append to the base url. The prepended question mark is optional; if it is missing, one will automatically be inserted.</p>
                        <p>The only callback triggered by AJAX datasets is the <code>on_all_rows_received</code> callback.</p>
                        <h5>Requesting further data</h5>
                        <p>A new dataset can be requested using the <code>request_dataset</code> method:</p>
                        <pre>
    // For WebSockets:
    d.request_dataset('{"cmd":"request_dataset"}');

    // For AJAX:
    d.request_dataset('query=string');</pre>
                        <p>The newly-requested dataset will completely replace the previously-requested dataset.</p>
                        <p>A new dataset can be requested and appended to the current dataset using the <code>request_dataset_for_append</code> method:</p>
                        <pre>
    // For WebSockets:
    d.request_dataset_for_append('{"cmd":"request_dataset"}');

    // For AJAX:
    d.request_dataset_for_append('query=string');</pre>
                        <p>Note that the newly-requested dataset should have the same columns as the previously-requested dataset.</p>
                    </section>
                    <section id="clone">
                        <h3>Clone</h3>
                        <p>A JData dataset can be deep-copied by calling <code>clone</code>:</p>
                        <pre>
    d.clone(function (new_d) {
        new_dataset = new_d;
    });</pre>
                        <p>Note that any streaming datasources are not copied as part of the cloning process.</p>
                    </section>
                    <section id="alter_columns">
                        <h3>Alter columns</h3>
                        <p>Column properties can be altered after JData is instantiated.</p>
                        <h5>Alter column name</h5>
                        <p>To change the name of <code>column_a</code> to <code>column_a1</code>:</p>
                        <pre>
    d.alter_column_name('column_a', 'column_a1');</pre>
                        <h5>Alter column title</h5>
                        <p>To change the title of <code>column_a</code> to <code>Things I Love</code>:</p>
                        <pre>
    d.alter_column_title('column_a', 'Things I Love');</pre>
                        <h5>Alter column aggregate type</h5>
                        <p>To change the aggregate type of <code>column_a</code> to <code>min</code>:</p>
                        <pre>
    d.alter_column_aggregate_type('column_a', 'min');</pre>
                        <p>Valid aggregate types are:</p>
                        <ul>
                            <li><code>max</code></li>
                            <li><code>min</code></li>
                            <li><code>sum</code></li>
                        </ul>
                        <h5>Alter column sort type</h5>
                        <p>To change the sort type of <code>column_a</code> to <code>num</code>:</p>
                        <pre>
    d.alter_column_sort_type('column_a', 'num');</pre>
                        <p>Valid sort types are:</p>
                        <ul>
                            <li><code>alpha</code></li>
                            <li><code>num</code></li>
                        </ul>
                        <p>Alternatively, you may pass in a sort function that takes two arguments <code>(a, b)</code> and returns <code>-1</code> for <code>a &lt b</code>, <code>1</code> for <code> a &gt b</code> or <code>0</code> for <code>a == b</code>.</p>
                        <h5>Prepend column names</h5>
                        <p>To prepend <code>a_</code> to all column names:</p>
                        <pre>
    d.prepend_column_names('a_');</pre>
                    </section>
                    <section id="append">
                        <h3>Append</h3>
                        <p>The <code>append</code> method is used to concatenate two datasets together. The following appends <code>dataset2</code> to <code>dataset1</code>:</p>
                        <pre>
    var dataset1 = [
        [ 'column_a', 'column_b', 'column_c' ],

        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
    ];
    var dataset2 = [
        [ 'column_a', 'column_b', 'column_c' ],

        [ 'gummy',       'power',    'apple' ],
        [ 'car',        'screen',    'phone' ],
        [ 'sign',        'bagel',    'chips' ]
    ];

    var d = new JData(dataset1);
    d.append(dataset2);</pre>
                        <p>Alternatively, you may also append a JData dataset:</p>
                        <pre>
    var dataset1 = [
        [ 'column_a', 'column_b', 'column_c' ],

        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
    ];
    var dataset2 = [
        [ 'column_a', 'column_b', 'column_c' ],

        [ 'gummy',       'power',    'apple' ],
        [ 'car',        'screen',    'phone' ],
        [ 'sign',        'bagel',    'chips' ]
    ];

    var d1 = new JData(dataset1);
    var d2 = new JData(dataset2);
    d1.append(d2);</pre>
                        <p>Note that column names must match up; an error will be thrown otherwise.</p>
                    </section>
                    <section id="filter">
                        <h3>Filter</h3>
                        <p>The <code>apply_filter</code> method is used to filter out rows that do not contain the specified regex. The following filters out any row that does not contain the word 'apple':</p>
                        <pre>
    d.apply_filter(/\bapple\b/)</pre>
                        <p>You may also filter only on certain columns:</p>
                        <pre>
    d.apply_filter(/\bapple\b/, 'column_a', 'column_b');</pre>
                        <p>Note that the following also works (and results in the exact same dataset):</p>
                        <pre>
    d.apply_filter(/\bapple\b/, [ 'column_a', 'column_b' ]);</pre>
                        <p>The filter can be cleared by calling the <code>clear_filters</code> method:</p>
                        <pre>
    d.clear_filters();</pre>
                        <p>To permanently remove rows from a dataset with a filter, use the <code>filter</code> method:</p>
                        <pre>
    d.filter(/\bapple\b/)</pre>
                    </section>
                    <section id="group">
                        <h3>Group</h3>
                        <p>Similar to grouping in SQL, the <code>group</code> method allows you to group rows together.</p>
                        <pre>
    d.group('column_a');</pre>
                        <p>You may also group by multiple rows:</p>
                        <pre>
    d.group('column_a', 'column_b');</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>
    d.group([ 'column_a', 'column_b' ]);</pre>
                        <p>Rows with the same value for the specified column(s) will be combined; the column property <code>agg_type</code> determines how values for non-specified columns are combined.</p>
                    </section>
                    <section id="join">
                        <h3>Join</h3>
                        <p>JData also supports joining via the <code>join</code> method. It can inner join, left outer join, or right outer join.</p>
                        <p>The following inner joins <code>d1</code> with <code>d2</code> on <code>column_a</code> from <code>d1</code> and <code>column_d</code> from <code>d2</code>:</p>
                        <pre>
    d1.join(d2, 'column_a', 'column_d');</pre>
                        <p>The following left outer joins <code>d1</code> with <code>d2</code> on <code>column_a</code> from <code>d1</code> and <code>column_d</code> from <code>d2</code>:</p>
                        <pre>
    d1.join(d2, 'column_a', 'column_d', 'left');</pre>
                        <p>The following right outer joins <code>d1</code> with <code>d2</code> on <code>column_a</code> from <code>d1</code> and <code>column_d</code> from <code>d2</code>:</p>
                        <pre>
    d1.join(d2, 'column_a', 'column_d', 'right');</pre>
                        <p>Joins can also be performed on multiple columns:</p>
                        <pre>
    d1.join(d2, [ 'column_a', 'column_b' ], [ 'column_d', 'column_e' ]);</pre>
                    </section>
                    <section id="limit">
                        <h3>Limit</h3>
                        <p>The <code>apply_limit</code> method limits the amount of visible rows in the dataset. The following allows only the first 10 rows in the dataset to be visible:</p>
                        <pre>   d.apply_limit(10);</pre>
                        <p>The limit can be cleared by calling the <code>clear_filters</code> method:</p>
                        <pre>   d.clear_filters();</pre>
                        <p>To permanently remove rows from a dataset with a limit, use the <code>limit</code> method:</p>
                        <pre>   d.limit(10)</pre>
                    </section>
                    <section id="remove_columns">
                        <h3>Remove columns</h3>
                        <p>You may completely delete columns from a dataset with the <code>remove_columns</code> method.
                        <pre>   d.remove_columns('column_a', 'column_b');</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>   d.remove_columns([ 'column_a', 'column_b' ]);</pre>
                    </section>
                    <section id="hide_columns">
                        <h3>Hide columns</h3>
                        <p>Instead of permanently deleting the columns, you may also temporarily hide them from view using the <code>hide_columns</code> method:</p>
                        <pre>   d.hide_columns('column_a', 'column_b');</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>   d.hide_columns([ 'column_a', 'column_b' ]);</pre>
                        <p>Hidden columns can be shown with the <code>show_columns</code> method:</p>
                        <pre>   d.show_columns('column_a', 'column_b');</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>   d.show_columns([ 'column_a', 'column_b' ]);</pre>
                        <p>The <code>hide_columns</code> and <code>show_columns</code> methods may also take a regex as an argument. Any column name matching the regex will be hidden/shown, respectively.</p>
                        <pre>   d.hide_columns(/^column_[ab]$/i);</pre>
                        <p>All hidden columns can be revealed with the <code>show_all_columns</code> method:</p>
                        <pre>   d.show_all_columns()</pre>
                        <p>Alternatively, you may retrieve all columns (visible AND non-visible) by using the <code>get_all_columns</code> method:</p>
                        <pre>
    d.get_all_columns(function (columns) {
        all_columns = columns; 
    })</pre>
                    </section>
                    <section id="sort">
                        <h3>Sort</h3>
                        <p>The following sorts the dataset on <code>column_a</code>:</p>
                        <pre>
    d.sort('column_a')</pre>
                        <p>To reverse sort, prepend the column name with a <code>-</code>:</p>
                        <pre>
    d.sort('-column_a')</pre>
                        <p>You may also sort on multiple columns:</p>
                        <pre>
    d.sort('column_a', '-column_b');</pre>
                        <p>In this case, the sort will fallback to <code>column_b</code> if the contents of <code>column_a</code> are equal.</p>
                        <p>Note that the following does the same thing:</p>
                        <pre>
    d.sort([ 'column_a', '-column_b' ]);</pre>
                    </section>
                    <section id="get_dataset">
                        <h3>Get dataset</h3>
                        <p>Visible dataset rows can be retrieved for use via the <code>get_dataset</code> method.</p>
                        <pre>
    var dataset = [
        [ 'column_a', 'column_b', 'column_c' ],

        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
        [ 'gummy',       'power',     'star' ]
    ];

    var d = new JData(dataset);
    var records;
    
    d.get_dataset(function (result) { records = result; });</pre>
                        <p>The following is the contents of <code>records</code>:</p>
                        <pre>
    [
        [ 'apple',      'violin',    'music' ],
        [ 'cat',        'tissue',      'dog' ],
        [ 'banana',      'piano',      'gum' ],
        [ 'gummy',       'power',     'star' ]
    ]</pre>
                        <p>The <code>get_dataset</code> method can also grab only specified rows:</p>
                        <pre>
    g.get_dataset(function (result) { records = result; }, 'column_a', 'column_b');</pre>
                        <p>The following would be the contents of <code>records</code>:</p>
                        <pre>
    [
        [ 'apple',      'violin' ],
        [ 'cat',        'tissue' ],
        [ 'banana',      'piano' ],
        [ 'gummy',       'power' ]
    ]</pre>
                        <p>Note that the following does the same thing as the preceding sample:</p>
                        <pre>
    g.get_dataset(
        function (result) { records = result; },
        [ 'column_a', 'column_b' ]
    );</pre>
                    </section>
                    <section id="get_columns">
                        <h3>Get columns</h3>
                        <p>The <code>get_columns</code> method is used to get the visible columns of the dataset:</p>
                        <pre>
    d.get_columns(function (columns) {
        visible_columns = columns;
    });</pre>
                        <p>Use <code>get_all_columns</code> to retrieve both visible and non-visible columns.</p>
                    </section>
                    <section id="get_columns_and_records">
                        <h3>Get columns and records</h3>
                        <p>Visible columns may be retrieved simultaneously with visible records with <code>get_columns_and_records</code>.</p>
                        <pre>
    d.get_columns_and_records(function (columns, records) {
        // Do something.
    });</pre>
                        <p>Columns will be given as a dictionary with the <code>column_name</code> as the key and its properties (also in a dictionary) as the value.</p>
                        <p>Records will be returned the same as in <code>get_dataset</code>.</p>
                    </section>
                    <section id="get_number_of_records">
                        <h3>Get number of records</h3>
                        <h5>Get number of records</h5>
                        <p>The <code>get_number_of_records</code> returns the number of visible rows currently in the dataset:</p>
                        <pre>
    d.get_number_of_records(function (num) {
        number_of_rows = num;
    });</pre>
                        <p>Note that for streaming datasets, this value will be the current number of rows it has (and not the total number of rows expected). Use <code>get_expected_number_of_records</code> to determine the total number of rows in a streaming dataset.</p>
                        <h5>Get expected number of records</h5>
                        <p>The <code>get_expected_number_of_records</code> method returns the expected number of records in a streaming dataset.</p>
                        <pre>
    d.get_expected_number_of_records(function (num) {
        expected_number_of_rows = num;
    });</pre>
                    </section>
                    <section id="get_distinct">
                        <h3>Get distinct</h3>
                        <h5>Get distinct consecutive rows</h5>
                        <p>Distinct rows can be retrieved using <code>get_distinct_consecutive_rows</code>. The function takes a <code>callback</code> and <code>column_name</code> as its parameters:</p>
                        <pre>
    function do_something_interesting(records) { }
    d.get_distinct_consecutive_rows(do_something_interesting, 'column_a');</pre>
                        <p>The value passed into the callback is an array of records. Each record contains three values: <code>value</code> of the column, <code>start_row</code> of that value, and <code>end_row</code> of that value.</p>
                        <p>If values are repeated again later, but not consecutively, another record will exist in the results. For example, with the following dataset:</p>
                        <pre>
    [
        [ 'column_a', 'column_b' ]

        [ 'abc',      '123'      ],
        [ 'abc',      '456'      ],
        [ 'abc',      '789'      ],
        [ 'def',      '123'      ],
        [ 'ghi',      '123'      ],
        [ 'ghi',      '456'      ],
        [ 'def',      '456'      ],
        [ 'def',      '789'      ]
    ]</pre>
                        <p>the function <code>get_distinct_consecutive_rows</code> will pass the following <code>records</code> into the callback as a sole parameter if 'column_a' were passed in as <code>column_name</code>:</p>
                        <pre>
    [
        [ 'abc', 0, 2 ],
        [ 'def', 3, 3 ],
        [ 'ghi', 4, 5 ],
        [ 'def', 6, 7 ]
    ]</pre>
                        <p>but if 'column_b' were passed in as <code>column_name</code> then the results would be:</p>
                        <pre>
    [
        [ '123', 0, 0 ],
        [ '456', 1, 1 ],
        [ '789', 2, 2 ],
        [ '123', 3, 4 ],
        [ '456', 5, 6 ],
        [ '789', 7, 7 ]
    ]</pre>
                        <p>The number of records returned will always be equal to or less than the number of records in the original dataset.</p>
                    </section>
                    <section id="paginate">
                        <h3>Pagination</h3>
                        <p>Pagination eases incremental of the records. The following sets JData to display 10 rows per page</p>
                        <pre>
    d.paginate(10);</pre>
                        <h5>Get next page</h5>
                        <p>Now you may grab the next 10 rows using the <code>get_next_page</code> method:</p>
                        <pre>
    var next_10_rows;
    
    d.get_next_page(function (result) { next_10_rows = result; });</pre>
                        <p>Grabbing the next page when you're on the last page will return an empty page.</p>
                        <h5>Get previous page</h5>
                        <p>The previous 10 rows can be grabbed using the <code>get_previous_page</code> method:</p>
                        <pre>
    var previous_10_rows;
    
    d.get_previous_page(function (result) { previous_10_rows = result; });</pre>
                        <p>Grabbing a previous page from the 1st page will simply return the 1st page again.</p>
                        <h5>Get page</h5>
                        <p>You may jump to a specific page using the <code>get_page</code> method. The following grabs page 4:</p>
                        <pre>
    var page;
    
    d.get_page(function (result) { page = result; }, 4);</pre>
                        <p>Note that this also sets your current page to the page you grab.</p>
                        <h5>Set page</h5>
                        <p>Use the <code>set_page</code> method to set a new current page. Attempting to set the page to 0 or a negative number will set the page to page 1. Setting to a page past the max number of current pages is allowed. The following sets your current page to page 4:</p>
                        <pre>
    d.set_page(4);</pre>
                    </section>
                    <section id="partition">
                        <h3>Partition</h3>
                        <p>JData can partition its dataset into multiple smaller datasets. The partitioned datasets can be retrieved afterwards using their partition key(s). The following partitions the dataset by the contents of <code>column_a</code> and uses the <code>get_partitioned</code> method to push each partition onto the <code>partitioned</code> array:</p>
                        <pre>
    var partitioned = [];

    d.partition('column_a');

    d.get_partition_keys().forEach(function (key) {
        d.get_partitioned(function (result) { partitioned.push(result); }, key);
    });</pre>
                        <p>They <code>get_partitioned</code> method returns an array of records.</code>
                        <p>You may also partition by multiple keys:</p>
                        <pre>
    d.partition('column_a', 'column_b');</pre>
                        <p>The following does the same thing:</p>
                        <pre>
    d.partition([ 'column_a', 'column_b' ]);</pre>
                    </section>
                    <section id="render">
                        <h3>Render</h3>
                        <p>The <code>render</code> method allows you to pass JData a function to render the dataset. When <code>render</code> is called without arguments, JData will call the rendering function that the user passed in, or do nothing if the user has not set a rendering function.</p>
                        <pre>
    d.render(function () { /* code for rendering the dataset */ });

    /* Make some changes to the dataset. */

    d.render(); // Renders the new dataset according to the user-defined function.</pre>
                    </section>
                </div>
            </div>
        </div>
    </body>
</html>
